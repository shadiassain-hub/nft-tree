{"version":3,"file":"index.js","mappings":"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","sources":["webpack://StacksNetwork/webpack/universalModuleDefinition","webpack://StacksNetwork/webpack/bootstrap","webpack://StacksNetwork/webpack/runtime/define property getters","webpack://StacksNetwork/webpack/runtime/hasOwnProperty shorthand","webpack://StacksNetwork/webpack/runtime/make namespace object","webpack://StacksNetwork/./src/constants.ts","webpack://StacksNetwork/../common/dist/esm/constants.js","webpack://StacksNetwork/../common/dist/esm/fetch.js","webpack://StacksNetwork/./src/network.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StacksNetwork\"] = factory();\n\telse\n\t\troot[\"StacksNetwork\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * The chain ID (unsigned 32-bit integer), used so transactions can't be replayed on other chains.\n * Similar to the {@link TransactionVersion}.\n */\nexport enum ChainId {\n  Mainnet = 0x00000001,\n  Testnet = 0x80000000,\n}\n\n/**\n * The **peer** network ID.\n * Typically not used in signing, but used for broadcasting to the P2P network.\n * It can also be used to determine the parent of a subnet.\n *\n * **Attention:**\n * For mainnet/testnet the v2/info response `.network_id` refers to the chain ID.\n * For subnets the v2/info response `.network_id` refers to the peer network ID and the chain ID (they are the same for subnets).\n * The `.parent_network_id` refers to the actual peer network ID (of the parent) in both cases.\n */\nexport enum PeerNetworkId {\n  Mainnet = 0x17000000,\n  Testnet = 0xff000000,\n}\n\nexport const DEFAULT_CHAIN_ID = ChainId.Mainnet;\n\n/**\n * The transaction version, used so transactions can't be replayed on other networks.\n * Similar to the {@link ChainId}.\n * Used internally for serializing and deserializing transactions.\n */\nexport enum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\n/**\n * Address versions for identifying address types in an encoded Stacks address.\n * The address version is a single byte, indicating the address type.\n * Every Stacks address starts with `S` followed by a single character indicating the address version.\n * The second character is the c32-encoded AddressVersion byte.\n */\nexport enum AddressVersion {\n  /** `P` — A single-sig address for mainnet (starting with `SP`) */\n  MainnetSingleSig = 22,\n  /** `M` — A multi-sig address for mainnet (starting with `SM`) */\n  MainnetMultiSig = 20,\n  /** `T` — A single-sig address for testnet (starting with `ST`) */\n  TestnetSingleSig = 26,\n  /** `N` — A multi-sig address for testnet (starting with `SN`) */\n  TestnetMultiSig = 21,\n}\n\nexport const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\n/** @ignore */\nexport function whenTransactionVersion(transactionVersion: TransactionVersion) {\n  return <T>(map: Record<TransactionVersion, T>): T => map[transactionVersion];\n}\n","export const HIRO_MAINNET_URL = 'https://api.mainnet.hiro.so';\nexport const HIRO_TESTNET_URL = 'https://api.testnet.hiro.so';\nexport const DEVNET_URL = 'http://localhost:3999';\nexport const GAIA_URL = 'https://hub.blockstack.org';\nexport const PRIVATE_KEY_BYTES_COMPRESSED = 33;\nexport const PRIVATE_KEY_BYTES_UNCOMPRESSED = 32;\n//# sourceMappingURL=constants.js.map","const defaultFetchOpts = {\n    referrerPolicy: 'origin',\n    headers: {\n        'x-hiro-product': 'stacksjs',\n    },\n};\nexport const getFetchOptions = () => {\n    return defaultFetchOpts;\n};\nexport const setFetchOptions = (ops) => {\n    return Object.assign(defaultFetchOpts, ops);\n};\nexport async function fetchWrapper(input, init) {\n    const fetchOpts = {};\n    Object.assign(fetchOpts, defaultFetchOpts, init);\n    const fetchResult = await fetch(input, fetchOpts);\n    return fetchResult;\n}\nexport function hostMatches(host, pattern) {\n    if (typeof pattern === 'string')\n        return pattern === host;\n    return pattern.exec(host);\n}\nexport function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)(\\.stacks\\.co|\\.hiro\\.so)$/i, httpHeader = 'x-api-key', }) {\n    return {\n        pre: context => {\n            const reqUrl = new URL(context.url);\n            if (!hostMatches(reqUrl.host, host))\n                return;\n            const headers = context.init.headers instanceof Headers\n                ? context.init.headers\n                : (context.init.headers = new Headers(context.init.headers));\n            headers.set(httpHeader, apiKey);\n        },\n    };\n}\nfunction argsForCreateFetchFn(args) {\n    let fetchLib = fetchWrapper;\n    let middlewares = [];\n    if (args.length > 0 && typeof args[0] === 'function') {\n        fetchLib = args.shift();\n    }\n    if (args.length > 0) {\n        middlewares = args;\n    }\n    return { fetchLib, middlewares };\n}\nexport function createFetchFn(...args) {\n    const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n    const fetchFn = async (url, init) => {\n        let fetchParams = { url, init: init ?? {} };\n        for (const middleware of middlewares) {\n            if (typeof middleware.pre === 'function') {\n                const result = await Promise.resolve(middleware.pre({\n                    fetch: fetchLib,\n                    ...fetchParams,\n                }));\n                fetchParams = result ?? fetchParams;\n            }\n        }\n        let response = await fetchLib(fetchParams.url, fetchParams.init);\n        for (const middleware of middlewares) {\n            if (typeof middleware.post === 'function') {\n                const result = await Promise.resolve(middleware.post({\n                    fetch: fetchLib,\n                    url: fetchParams.url,\n                    init: fetchParams.init,\n                    response: response?.clone() ?? response,\n                }));\n                response = result ?? response;\n            }\n        }\n        return response;\n    };\n    return fetchFn;\n}\n//# sourceMappingURL=fetch.js.map","import {\n  DEVNET_URL,\n  FetchFn,\n  HIRO_MAINNET_URL,\n  HIRO_TESTNET_URL,\n  createFetchFn,\n  createApiKeyMiddleware,\n  ClientOpts,\n  ApiKeyMiddlewareOpts,\n} from '@stacks/common';\nimport { AddressVersion, ChainId, PeerNetworkId, TransactionVersion } from './constants';\nimport { ClientParam } from '@stacks/common';\n\nexport type StacksNetwork = {\n  chainId: number;\n  transactionVersion: number;\n  peerNetworkId: number;\n  magicBytes: string;\n  bootAddress: string;\n  addressVersion: {\n    singleSig: number;\n    multiSig: number;\n  };\n  // todo: add check32 character bytes string\n  client: {\n    baseUrl: string; // URL is always required\n    fetch?: FetchFn; // fetch is optional and will be created by default in fetch helpers\n  };\n};\n\nexport interface NetworkParam {\n  network?: StacksNetworkName | StacksNetwork;\n}\n\nexport type NetworkClientParam = NetworkParam & ClientParam;\n\nexport const STACKS_MAINNET: StacksNetwork = {\n  chainId: ChainId.Mainnet,\n  transactionVersion: TransactionVersion.Mainnet,\n  peerNetworkId: PeerNetworkId.Mainnet,\n  magicBytes: 'X2', // todo: comment bytes version of magic bytes\n  bootAddress: 'SP000000000000000000002Q6VF78',\n  addressVersion: {\n    singleSig: AddressVersion.MainnetSingleSig,\n    multiSig: AddressVersion.MainnetMultiSig,\n  },\n  client: { baseUrl: HIRO_MAINNET_URL },\n};\n\nexport const STACKS_TESTNET: StacksNetwork = {\n  chainId: ChainId.Testnet,\n  transactionVersion: TransactionVersion.Testnet,\n  peerNetworkId: PeerNetworkId.Testnet,\n  magicBytes: 'T2', // todo: comment bytes version of magic bytes\n  bootAddress: 'ST000000000000000000002AMW42H',\n  addressVersion: {\n    singleSig: AddressVersion.TestnetSingleSig,\n    multiSig: AddressVersion.TestnetMultiSig,\n  },\n  client: { baseUrl: HIRO_TESTNET_URL },\n};\n\nexport const STACKS_DEVNET: StacksNetwork = {\n  ...STACKS_TESTNET, // todo: ensure deep copy\n  addressVersion: { ...STACKS_TESTNET.addressVersion }, // deep copy\n  magicBytes: 'id', // todo: comment bytes version of magic bytes\n  client: { baseUrl: DEVNET_URL },\n};\n\nexport const STACKS_MOCKNET: StacksNetwork = {\n  ...STACKS_DEVNET,\n  addressVersion: { ...STACKS_DEVNET.addressVersion }, // deep copy\n  client: { ...STACKS_DEVNET.client }, // deep copy\n};\n\n/** @ignore internal */\nexport const StacksNetworks = ['mainnet', 'testnet', 'devnet', 'mocknet'] as const;\n/** The enum-style names of different common Stacks networks */\nexport type StacksNetworkName = (typeof StacksNetworks)[number];\n\n/**\n * Returns the default network for a given name\n * @example\n * ```ts\n * networkFromName('mainnet') // same as STACKS_MAINNET\n * networkFromName('testnet') // same as STACKS_TESTNET\n * networkFromName('devnet') // same as STACKS_DEVNET\n * networkFromName('mocknet') // same as STACKS_MOCKNET\n * ```\n */\nexport function networkFromName(name: StacksNetworkName) {\n  switch (name) {\n    case 'mainnet':\n      return STACKS_MAINNET;\n    case 'testnet':\n      return STACKS_TESTNET;\n    case 'devnet':\n      return STACKS_DEVNET;\n    case 'mocknet':\n      return STACKS_MOCKNET;\n    default:\n      throw new Error(`Unknown network name: ${name}`);\n  }\n}\n\n/** @ignore */\nexport function networkFrom(network: StacksNetworkName | StacksNetwork) {\n  if (typeof network === 'string') return networkFromName(network);\n  return network;\n}\n\n/** @ignore */\nexport function defaultUrlFromNetwork(network?: StacksNetworkName | StacksNetwork) {\n  if (!network) return HIRO_MAINNET_URL; // default to mainnet if no network is given\n\n  network = networkFrom(network);\n\n  return !network || network.transactionVersion === TransactionVersion.Mainnet\n    ? HIRO_MAINNET_URL // default to mainnet if txVersion is mainnet\n    : network.magicBytes === 'id'\n      ? DEVNET_URL // default to devnet if magicBytes are devnet\n      : HIRO_TESTNET_URL;\n}\n\n/**\n * Returns the client of a network, creating a new fetch function if none is available\n */\nexport function clientFromNetwork(network: StacksNetwork): Required<ClientOpts> {\n  if (network.client.fetch) return network.client as Required<ClientOpts>;\n  return {\n    ...network.client,\n    fetch: createFetchFn(),\n  };\n}\n\n/**\n * Creates a customized Stacks network.\n *\n * This function allows you to create a network based on a predefined network\n * (mainnet, testnet, devnet, mocknet) or a custom network object. You can also customize\n * the network with an API key or other client options.\n *\n * @example\n * ```ts\n * // Create a basic network from a network name\n * const network = createNetwork('mainnet');\n * const network = createNetwork(STACKS_MAINNET);\n * ```\n *\n * @example\n * ```ts\n * // Create a network with an API key\n * const network = createNetwork('testnet', 'my-api-key');\n * const network = createNetwork(STACKS_TESTNET, 'my-api-key');\n * ```\n *\n * @example\n * ```ts\n * // Create a network with options object\n * const network = createNetwork({\n *   network: 'mainnet',\n *   apiKey: 'my-api-key',\n * });\n * ```\n *\n * @example\n * ```ts\n * // Create a network with options object with custom API key options\n * const network = createNetwork({\n *   network: 'mainnet',\n *   apiKey: 'my-api-key',\n *   host: /\\.example\\.com$/, // default is /(.*)api(.*)(\\.stacks\\.co|\\.hiro\\.so)$/i\n *   httpHeader: 'x-custom-api-key', // default is 'x-api-key'\n * });\n * ```\n *\n * @example\n * ```ts\n * // Create a network with custom client options\n * const network = createNetwork({\n *   network: STACKS_TESTNET,\n *   client: {\n *     baseUrl: 'https://custom-api.example.com',\n *     fetch: customFetchFunction\n *   }\n * });\n * ```\n */\nexport function createNetwork(network: StacksNetworkName | StacksNetwork): StacksNetwork;\nexport function createNetwork(\n  network: StacksNetworkName | StacksNetwork,\n  apiKey: string\n): StacksNetwork;\nexport function createNetwork(\n  options: {\n    network: StacksNetworkName | StacksNetwork;\n    client?: ClientOpts;\n  } & Partial<ApiKeyMiddlewareOpts>\n): StacksNetwork;\nexport function createNetwork(\n  arg1:\n    | StacksNetworkName\n    | StacksNetwork\n    | ({\n        network: StacksNetworkName | StacksNetwork;\n        client?: ClientOpts;\n      } & Partial<ApiKeyMiddlewareOpts>),\n  arg2?: string\n): StacksNetwork {\n  const baseNetwork = networkFrom(\n    typeof arg1 === 'object' && 'network' in arg1 ? arg1.network : arg1\n  );\n\n  const newNetwork: StacksNetwork = {\n    ...baseNetwork,\n    addressVersion: { ...baseNetwork.addressVersion }, // deep copy\n    client: { ...baseNetwork.client }, // deep copy\n  };\n\n  // Options object argument\n  if (typeof arg1 === 'object' && 'network' in arg1) {\n    if (arg1.client) {\n      newNetwork.client.baseUrl = arg1.client.baseUrl ?? newNetwork.client.baseUrl;\n      newNetwork.client.fetch = arg1.client.fetch ?? newNetwork.client.fetch;\n    }\n\n    if (typeof arg1.apiKey === 'string') {\n      const middleware = createApiKeyMiddleware(arg1 as ApiKeyMiddlewareOpts);\n      newNetwork.client.fetch = newNetwork.client.fetch\n        ? createFetchFn(newNetwork.client.fetch, middleware)\n        : createFetchFn(middleware);\n    }\n\n    return newNetwork;\n  }\n\n  // Additional API key argument\n  if (typeof arg2 === 'string') {\n    const middleware = createApiKeyMiddleware({ apiKey: arg2 });\n    newNetwork.client.fetch = newNetwork.client.fetch\n      ? createFetchFn(newNetwork.client.fetch, middleware)\n      : createFetchFn(middleware);\n    return newNetwork;\n  }\n\n  // Only network argument\n  return newNetwork;\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ChainId","PeerNetworkId","DEFAULT_CHAIN_ID","TransactionVersion","AddressVersion","DEFAULT_TRANSACTION_VERSION","whenTransactionVersion","transactionVersion","map","HIRO_MAINNET_URL","HIRO_TESTNET_URL","DEVNET_URL","defaultFetchOpts","referrerPolicy","headers","async","fetchWrapper","input","init","fetchOpts","assign","fetch","createApiKeyMiddleware","apiKey","host","httpHeader","pre","context","pattern","exec","hostMatches","URL","url","Headers","set","createFetchFn","args","fetchLib","middlewares","length","shift","argsForCreateFetchFn","fetchParams","middleware","Promise","resolve","response","post","result","clone","STACKS_MAINNET","chainId","Mainnet","peerNetworkId","magicBytes","bootAddress","addressVersion","singleSig","MainnetSingleSig","multiSig","MainnetMultiSig","client","baseUrl","STACKS_TESTNET","Testnet","TestnetSingleSig","TestnetMultiSig","STACKS_DEVNET","STACKS_MOCKNET","StacksNetworks","networkFromName","name","Error","networkFrom","network","defaultUrlFromNetwork","clientFromNetwork","createNetwork","arg1","arg2","baseNetwork","newNetwork"],"sourceRoot":""}