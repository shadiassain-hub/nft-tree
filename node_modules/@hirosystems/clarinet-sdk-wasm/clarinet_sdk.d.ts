/* tslint:disable */
/* eslint-disable */
export type EpochString = "2.0" | "2.05" | "2.1" | "2.2" | "2.3" | "2.4" | "2.5" | "3.0"

type Atom = {
  Atom: String;
};

type AtomValue = {
  AtomValue: any;
};

type List = {
  List: Expression[];
};

type LiteralValue = {
  LiteralValue: any;
};

type Field = {
  Field: any;
};

type TraitReference = {
  TraitReference: any;
};

type ExpressionType = Atom | AtomValue | List | LiteralValue | Field | TraitReference;

type Span = {
  start_line: number;
  start_column: number;
  end_line: number;
  end_column: number;
};

type Expression = {
  expr: ExpressionType;
  id: number;
  span: Span;
};

type IContractAST = {
  contract_identifier: any;
  pre_expressions: any[];
  expressions: Expression[];
  top_level_expression_sorting: number[];
  referenced_traits: Map<any, any>;
  implemented_traits: any[];
};

type ContractInterfaceFunctionAccess = "private" | "public" | "read_only";

type ContractInterfaceTupleEntryType = { name: string; type: ContractInterfaceAtomType };

type ContractInterfaceAtomType =
  | "none"
  | "int128"
  | "uint128"
  | "bool"
  | "principal"
  | { buffer: { length: number } }
  | { "string-utf8": { length: number } }
  | { "string-ascii": { length: number } }
  | { tuple: ContractInterfaceTupleEntryType[] }
  | { optional: ContractInterfaceAtomType }
  | { response: { ok: ContractInterfaceAtomType; error: ContractInterfaceAtomType } }
  | { list: { type: ContractInterfaceAtomType; length: number } }
  | "trait_reference";

type ContractInterfaceFunctionArg = { name: string; type: ContractInterfaceAtomType };

type ContractInterfaceFunctionOutput = { type: ContractInterfaceAtomType };

type ContractInterfaceFunction = {
  name: string;
  access: ContractInterfaceFunctionAccess;
  args: ContractInterfaceFunctionArg[];
  outputs: ContractInterfaceFunctionOutput;
};

type ContractInterfaceVariableAccess = "constant" | "variable";

type ContractInterfaceVariable = {
  name: string;
  type: ContractInterfaceAtomType;
  access: ContractInterfaceVariableAccess;
};

type ContractInterfaceMap = {
  name: string;
  key: ContractInterfaceAtomType;
  value: ContractInterfaceAtomType;
};

type ContractInterfaceFungibleTokens = { name: string };

type ContractInterfaceNonFungibleTokens = { name: string; type: ContractInterfaceAtomType };

export type StacksEpochId =
  | "Epoch10"
  | "Epoch20"
  | "Epoch2_05"
  | "Epoch21"
  | "Epoch22"
  | "Epoch23"
  | "Epoch24"
  | "Epoch25"
  | "Epoch30"
  | "Epoch31"
  | "Epoch32";

export type ClarityVersionString = "Clarity1" | "Clarity2" | "Clarity3";

export type IContractInterface = {
  functions: ContractInterfaceFunction[];
  variables: ContractInterfaceVariable[];
  maps: ContractInterfaceMap[];
  fungible_tokens: ContractInterfaceFungibleTokens[];
  non_fungible_tokens: ContractInterfaceNonFungibleTokens[];
  epoch: StacksEpochId;
  clarity_version: ClarityVersionString;
};

export class CallFnArgs {
  free(): void;
  constructor(contract: string, method: string, args: Uint8Array[], sender: string);
}
export class ContractOptions {
  free(): void;
  constructor(clarity_version?: number | null);
}
export class DeployContractArgs {
  free(): void;
  constructor(name: string, content: string, options: ContractOptions, sender: string);
}
export class SDK {
  free(): void;
  constructor(fs_request: Function, options?: SDKOptions | null);
  static getDefaultEpoch(): EpochString;
  getDefaultClarityVersionForCurrentEpoch(): ClarityVersionString;
  initEmptySession(remote_data_settings: any): Promise<void>;
  initSession(cwd: string, manifest_path: string): Promise<void>;
  clearCache(): void;
  setEpoch(epoch: EpochString): void;
  getContractsInterfaces(): Map<string, IContractInterface>;
  getContractSource(contract: string): string | undefined;
  getContractAST(contract: string): IContractAST;
  getAssetsMap(): Map<string, Map<string, bigint>>;
  getAccounts(): Map<string, string>;
  getDataVar(contract: string, var_name: string): string;
  getBlockTime(): bigint;
  getMapEntry(contract: string, map_name: string, map_key: Uint8Array): string;
  callReadOnlyFn(args: CallFnArgs): TransactionRes;
  deployContract(args: DeployContractArgs): TransactionRes;
  transferSTX(args: TransferSTXArgs): TransactionRes;
  callPublicFn(args: CallFnArgs): TransactionRes;
  callPrivateFn(args: CallFnArgs): TransactionRes;
  mineBlock(js_txs: Array<any>): any;
  mineEmptyBlock(): number;
  mineEmptyBlocks(count?: number | null): number;
  mineEmptyStacksBlock(): number;
  mineEmptyStacksBlocks(count?: number | null): number;
  mineEmptyBurnBlock(): number;
  mineEmptyBurnBlocks(count?: number | null): number;
  runSnippet(snippet: string): string;
  execute(snippet: string): TransactionRes;
  executeCommand(snippet: string): string;
  setLocalAccounts(addresses: string[]): void;
  mintSTX(recipient: string, amount: bigint): string;
  setCurrentTestName(test_name: string): void;
  collectReport(include_boot_contracts: boolean, boot_contracts_path: string): SessionReport;
  deployer: string;
  readonly blockHeight: number;
  readonly stacksBlockHeight: number;
  readonly burnBlockHeight: number;
  readonly currentEpoch: string;
}
export class SDKOptions {
  free(): void;
  constructor(track_costs: boolean, track_coverage: boolean);
  trackCosts: boolean;
  trackCoverage: boolean;
}
export class SessionReport {
  private constructor();
  free(): void;
  coverage: string;
  costs: string;
}
export class TransactionRes {
  private constructor();
  free(): void;
  result: string;
  events: string;
  costs: string;
}
export class TransferSTXArgs {
  free(): void;
  constructor(amount: bigint, recipient: string, sender: string);
}
export class TxArgs {
  private constructor();
  free(): void;
}
